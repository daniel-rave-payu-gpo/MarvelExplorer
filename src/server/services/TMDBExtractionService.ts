import axios, { AxiosInstance } from 'axios';
import { Logger } from 'pino';
import { MarvelRepository } from '../../repositories/MarvelRepository';
import {
  TMDBExtractionData,
  TMDBMovieResponse,
  TMDBMovieCreditsResponse,
  TMDBExtractionResult,
} from '../../dto/TMDBDataDto';
import { tmdbExtractionData } from '../../config/tmdbExtractionData';

export class TMDBExtractionService {
  private tmdbClient: AxiosInstance;
  private logger: Logger;
  private marvelRepository: MarvelRepository;
  private readonly tmdbAccessToken: string;

  // The specific data to extract
  private readonly extractionData: TMDBExtractionData = tmdbExtractionData;

  constructor(logger: Logger, marvelRepository: MarvelRepository, tmdbAccessToken: string) {
    this.logger = logger;
    this.marvelRepository = marvelRepository;
    this.tmdbAccessToken = tmdbAccessToken;
    if (!this.tmdbAccessToken) {
      throw new Error('TMDB access token (TMDB_ACCESS_TOKEN) is required');
    }
    this.tmdbClient = axios.create({
      baseURL: 'https://api.themoviedb.org/3',
      headers: {
        Authorization: `Bearer ${this.tmdbAccessToken}`,
        'Content-Type': 'application/json',
      },
    });
  }

  async extractAndStoreData(): Promise<TMDBExtractionResult> {
    this.logger.info('Starting TMDB data extraction for specified movies and actors');

    const result: TMDBExtractionResult = {
      movies: [],
      actors: [],
      characters: [],
    };

    // Process each movie
    for (const [movieTitle, tmdbId] of Object.entries(this.extractionData.movies)) {
      try {
        this.logger.info({ movieTitle, tmdbId }, 'Processing movie');

        // Fetch movie data from TMDB
        const movieData = await this.getMovie(tmdbId);

        // Store movie in database and get the database ID
        const savedMovie = await this.marvelRepository.saveMovie({
          id: movieData.id,
          title: movieData.title,
          release_date: movieData.release_date,
          overview: movieData.overview,
          poster_path: movieData.poster_path || null,
        });

        result.movies.push({
          id: savedMovie.id,
          title: movieData.title,
          tmdbId: tmdbId,
        });

        // Process cast members and filter for our specific actors
        if (movieData.credits?.cast) {
          for (const castMember of movieData.credits.cast) {
            // Check if this actor is in our target list
            this.logger.info(
              { actorName: castMember.name, isInTargetList: this.extractionData.actors.includes(castMember.name) },
              'Checking actor',
            );
            if (this.extractionData.actors.includes(castMember.name)) {
              // Get or create actor
              let savedActor;
              const existingActor = await this.marvelRepository.getActorByTmdbId(castMember.id);

              this.logger.info(
                { actorName: castMember.name, tmdbId: castMember.id, existingActor: !!existingActor },
                'Processing actor',
              );

              if (!existingActor) {
                // Create new actor
                this.logger.info({ actorName: castMember.name }, 'Creating new actor');
                savedActor = await this.marvelRepository.saveActor({
                  id: castMember.id,
                  name: castMember.name,
                  profile_path: castMember.profile_path || null,
                });

                result.actors.push({
                  id: savedActor.id,
                  name: castMember.name,
                  tmdbId: castMember.id,
                });
              } else {
                // Use existing actor
                this.logger.info(
                  { actorName: castMember.name, existingActorId: existingActor.id },
                  'Using existing actor',
                );
                savedActor = { id: existingActor.id };
              }

              // Store character relationship using database IDs
              if (savedActor) {
                await this.marvelRepository.saveCharacter({
                  id: 0, // Auto-generated by database
                  name: castMember.character,
                  movie_id: savedMovie.id,
                  actor_id: savedActor.id,
                });

                result.characters.push({
                  name: castMember.character,
                  movieId: savedMovie.id,
                  actorId: savedActor.id,
                });
              }
            }
          }
        }

        this.logger.info({ movieTitle }, 'Successfully processed movie');
      } catch (error) {
        this.logger.error({ movieTitle, tmdbId, error }, 'Error processing movie');
        // Propagate the error so the controller can return a non-success response
        throw error;
      }
    }

    this.logger.info(
      {
        moviesProcessed: result.movies.length,
        actorsProcessed: result.actors.length,
        charactersProcessed: result.characters.length,
      },
      'TMDB data extraction completed',
    );

    return result;
  }

  async replaceAndStoreData(): Promise<TMDBExtractionResult> {
    this.logger.info('Starting TMDB data replacement - clearing existing data first');

    // Clear all existing data
    await this.clearAllData();

    this.logger.info('Existing data cleared, starting fresh extraction');

    // Now extract and store fresh data
    return await this.extractAndStoreData();
  }

  private async clearAllData(): Promise<void> {
    try {
      this.logger.info('Clearing all existing data from database');

      // Clear in the correct order to respect foreign key constraints
      await this.marvelRepository.clearAllCharacters();
      await this.marvelRepository.clearAllMovies();
      await this.marvelRepository.clearAllActors();

      this.logger.info('All existing data cleared successfully');
    } catch (error) {
      this.logger.error({ error }, 'Error clearing existing data');
      throw error;
    }
  }

  async getMovie(movieId: number): Promise<TMDBMovieResponse> {
    this.logger.info({ movieId }, 'Fetching movie from TMDB');
    return await this.requestWithRetry<TMDBMovieResponse>(`/movie/${movieId}?append_to_response=credits`);
  }

  async getMovieCredits(movieId: number): Promise<TMDBMovieCreditsResponse> {
    this.logger.info({ movieId }, 'Fetching movie credits from TMDB');
    return await this.requestWithRetry<TMDBMovieCreditsResponse>(`/movie/${movieId}/credits`);
  }

  getExtractionData(): TMDBExtractionData {
    return this.extractionData;
  }

  async getStats(): Promise<any> {
    try {
      this.logger.info('Fetching aggregated statistics');
      const stats = await this.marvelRepository.getStats();
      return stats;
    } catch (error) {
      this.logger.error({ error }, 'Error fetching aggregated statistics');
      throw error;
    }
  }

  private async requestWithRetry<T>(path: string, maxRetries = 3): Promise<T> {
    let attempt = 0;
    let lastError: any;
    const baseDelayMs = 1000;
    while (attempt <= maxRetries) {
      try {
        const response = await this.tmdbClient.get(path);
        return response.data as T;
      } catch (error: any) {
        lastError = error;
        const status = error?.response?.status;
        const retryAfterHeader = error?.response?.headers?.['retry-after'];
        const isRetriable = status === 429 || (status >= 500 && status < 600) || !status;
        if (!isRetriable || attempt === maxRetries) {
          this.logger.error({ path, status, attempt, error }, 'TMDB request failed');
          break;
        }
        attempt += 1;
        let delay = baseDelayMs;
        if (status === 429 && retryAfterHeader) {
          const parsed = Number(retryAfterHeader);
          if (!Number.isNaN(parsed)) {
            delay = Math.max(baseDelayMs, parsed * 1000);
          }
        }
        this.logger.warn({ path, status, attempt, sleepMs: delay }, 'Retrying TMDB request');
        await this.sleep(delay);
        continue;
      }
    }
    throw lastError;
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
